/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package gr.uop;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.ParseException;
import java.time.LocalDateTime;
import java.util.Scanner;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Comparator;


public class Server {
    
    //public final static int QUERY_PORT = 7777, DATA_PORT = QUERY_PORT+1, FILE_PORT=DATA_PORT+1;
    

    public static void main(String[] args) {
        
        
        //load port constants
        Path filePath = Paths.get("shared.txt");
        final int QUERY_PORT, DATA_INPUT_PORT, FILE_PORT;
        int qp = 0,dip = 0,fp = 0;
        try (Scanner port_constants = new Scanner(filePath)) {
            qp = Integer.parseInt(port_constants.next());
            dip = Integer.parseInt(port_constants.next());
            fp = Integer.parseInt(port_constants.next());

        } catch (NumberFormatException | IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            System.exit(0);
        }
        QUERY_PORT = qp;
        DATA_INPUT_PORT = dip;
        FILE_PORT = fp;
        //if qp, dip and fp don't change, it means an exception was thrown and the program will stop

        System.out.println("\n\nRunning F.A.L.S.E. back-end.");
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");  
        LocalDateTime now = LocalDateTime.now();  
        System.out.println(dtf.format(now)+"\n\n");
        
        new Thread(()->{
            try (ServerSocket serverSocket = new ServerSocket(DATA_INPUT_PORT)) {
                while(true){
                    Socket clientSocket = serverSocket.accept();
                    handleDataInputConnection(clientSocket);
                }
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }).start();
        
        try (ServerSocket serverSocket = new ServerSocket(QUERY_PORT);) {     
            while(true){
                Socket clientSocket = serverSocket.accept();
                handleQueryConnection(clientSocket, QUERY_PORT);
            }

        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    /**
     * Handles a client data connection
     * @param clientSocket
     */
    private static void handleDataInputConnection(Socket clientSocket) {
        try (ObjectOutputStream toClient = new ObjectOutputStream(clientSocket.getOutputStream());
            ObjectInputStream fromClient = new ObjectInputStream(clientSocket.getInputStream())) {     
           
            //send all known data to client
            //test data
            String read = "TEST";
            SearchResult s1 = new SearchResult(read, read+" "+read);
            SearchResult s2 = new SearchResult(read+"1 "+read, read+"1 "+read+" "+ read+"abc "+read+" 123"+read);
            
            ArrayList<SearchResult> dataStored = new ArrayList<>();
            dataStored.add(s1);
            dataStored.add(s2);
            sendData(toClient, dataStored);

            //receive new data from client, and delete from storage space
            ArrayList<SearchResult> clientData = new ArrayList<>();
            receiveData(fromClient, clientData);

            clientSocket.close();
        } catch (IOException | ClassNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    private static void receiveData(ObjectInputStream fromClient, ArrayList<SearchResult> clientData) throws ClassNotFoundException, IOException {
        do{
            SearchResult s = (SearchResult)fromClient.readObject();
            if(s == null){break;}
            clientData.add(s);
        }while(true);
    }

    private static void sendData(ObjectOutputStream toClient, ArrayList<SearchResult> results) throws IOException{
        for(SearchResult s : results){
            toClient.writeObject(s);
        }toClient.writeObject(null);//MUST send a null object so the client can know there's nothing more to read.
    }

    /**
     * Handles a client query connection
     * @param clientSocket the socket to handle
     */
    private static void handleQueryConnection(Socket clientSocket, int port) {          
        try (Scanner input = new Scanner(clientSocket.getInputStream());
             ObjectOutputStream toClient = new ObjectOutputStream(clientSocket.getOutputStream())) {
                
            String read = input.nextLine();
            System.out.println("Front-end sent: '"+read+"' at "+getCurrentTime()+"\n");


            //test objects, must send search results here.
            LuceneEngine luceneEngine;
            try {
                luceneEngine = new LuceneEngine();
                luceneEngine.createIndex();
                luceneEngine.search(read);
            } catch (IOException | ParseException e) {
                e.printStackTrace();
            }
            
            
            ArrayList<SearchResult> results = new ArrayList<>();

            sendData(toClient, results);

            clientSocket.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    /**
     * 
     * @return a String with the current date and time
     */
    private static String getCurrentTime() {
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");  
        LocalDateTime now = LocalDateTime.now();
        return dtf.format(now);
    }
}
