/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package gr.uop;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Scanner;



public class Server {
    
    //public final static int QUERY_PORT = 7777, DATA_PORT = QUERY_PORT+1, FILE_PORT=DATA_PORT+1;
    private static LuceneEngine luceneEngine = new LuceneEngine(0);//0 means all there are
    

    public static void main(String[] args) {
        //create index at startup
        try{
            luceneEngine.createIndex();
        }catch(IOException e){
            System.out.println("Indexing failed!");
        }
        
        //load port constants
        Path filePath = Paths.get("shared.txt");
        final int QUERY_PORT, SINGLE_DATA_INPUT_PORT, DATA_DEL_PORT, DATA_DEL_PORT_2;
        int qp = 0, dip = 0, ddp = 0, ddp2 = 0;
        try (Scanner port_constants = new Scanner(filePath)) {
            qp = Integer.parseInt(port_constants.next());
            dip = Integer.parseInt(port_constants.next());
            ddp = Integer.parseInt(port_constants.next());
            ddp2 = Integer.parseInt(port_constants.next());
        } catch (NumberFormatException | IOException e) {
            e.printStackTrace();
            System.exit(0);
        }
        QUERY_PORT = qp;
        SINGLE_DATA_INPUT_PORT = dip;
        DATA_DEL_PORT = ddp;
        DATA_DEL_PORT_2 = ddp2;
        //if qp, dip and ddp don't change, it means an exception was thrown and the program will stop

        System.out.println("\n\nRunning F.A.L.S.E. back-end.");
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");  
        LocalDateTime now = LocalDateTime.now();  
        System.out.println(dtf.format(now)+"\n\n");
        
        new Thread(()->{
            try (ServerSocket serverSocket = new ServerSocket(SINGLE_DATA_INPUT_PORT)) {
                while(true){
                    Socket clientSocket = serverSocket.accept();
                    System.out.println("Here");
                    handleSingleDataInputConnection(clientSocket);
                }
            } catch (IOException e) { e.printStackTrace(); }
        }).start();

        new Thread(()->{
            try(ServerSocket serverSocket = new ServerSocket(DATA_DEL_PORT)){
                while(true){
                    Socket clientSocket = serverSocket.accept();
                    handleDataDeletion(clientSocket, DATA_DEL_PORT_2);
                }
            }catch(IOException e){ e.printStackTrace(); }
        }).start();
        
        try (ServerSocket serverSocket = new ServerSocket(QUERY_PORT);) {     
            while(true){
                Socket clientSocket = serverSocket.accept();
                handleQueryConnection(clientSocket, QUERY_PORT);
            }

        } catch (IOException e) { e.printStackTrace(); }
    }

    private static void handleSingleDataInputConnection(Socket clientSocket) {//client will send a SongInfo to add, must send response back
        try(ObjectInputStream fromClient = new ObjectInputStream(clientSocket.getInputStream());
            ObjectOutputStream toClient = new ObjectOutputStream(clientSocket.getOutputStream())){    
                SongInfo si = (SongInfo)fromClient.readObject();
                System.out.println("Front-end sent data to add: '"+si+"' at "+getCurrentTime());
                String response = luceneEngine.addToIndex(si);
                toClient.writeObject(response);
                System.out.println("Sent response: "+response);
                clientSocket.close();
        }catch(IOException | ClassNotFoundException e){ e.printStackTrace(); }
    }

    /**
     * Handles a client data deletion connection
     * @param clientSocket
     */
    private static void handleDataDeletion(Socket clientSocket, int port2) {
        try (ObjectOutputStream toClient = new ObjectOutputStream(clientSocket.getOutputStream())) {     
            System.out.println("Front-end sent request to delete data at: "+getCurrentTime());
           
            ArrayList<SongInfo> dataStored = new ArrayList<>();
            //send all known data to client
            dataStored = luceneEngine.getAllSongDocs();

            sendSongInfoData(toClient, dataStored);
            System.out.println("Finished sending data at: "+getCurrentTime());

            ServerSocket serverSocket = new ServerSocket(port2);//previous connection will be closed
            Socket newCliSocket = serverSocket.accept();
            ObjectInputStream fromClient = new ObjectInputStream(newCliSocket.getInputStream());

            //receive new data from client, and delete from storage space
            ArrayList<SongInfo> clientData = new ArrayList<>();
            receiveSongInfoData(fromClient, clientData);
            luceneEngine.deleteSongDocs(clientData);
            System.out.println("Deleted data");

            newCliSocket.close();
            clientSocket.close();
            serverSocket.close();
        } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); }
    }

    private static void receiveSongInfoData(ObjectInputStream fromClient, ArrayList<SongInfo> clientData) throws ClassNotFoundException, IOException {
        do{
            SongInfo s = (SongInfo)fromClient.readObject();
            if(s == null){break;}
            clientData.add(s);
        }while(true);
    }

    private static void sendSongInfoData(ObjectOutputStream toClient, ArrayList<SongInfo> results) throws IOException{
        for(SongInfo s : results){ toClient.writeObject(s); }toClient.writeObject(null);//MUST send a null object so the client can know there's nothing more to read.
    }
    private static void sendSearchResultData(ObjectOutputStream toClient, ArrayList<SearchResult> results) throws IOException{
        for(SearchResult s : results){ toClient.writeObject(s); }toClient.writeObject(null);//MUST send a null object so the client can know there's nothing more to read.
    }

    /**
     * Handles a client query connection
     * @param clientSocket the socket to handle
     */
    private static void handleQueryConnection(Socket clientSocket, int port) {          
        try (Scanner input = new Scanner(clientSocket.getInputStream());
             ObjectOutputStream toClient = new ObjectOutputStream(clientSocket.getOutputStream())) {
                
            String read = input.nextLine();
            String numStr = input.nextLine();
            String searchField = input.nextLine();
            int max_res = Integer.parseInt(numStr);
            System.out.println("Front-end sent: '"+read+"' at "+getCurrentTime());
            System.out.println("Search for: ["+max_res+"] top results (0 means all there are) in field: ["+searchField+"]\n");

            try {
                //must send results to client
                ArrayList<SearchResult> results = new ArrayList<>();
                luceneEngine.setMaxResults(max_res);
                luceneEngine.setSearchField(searchField);
                results = luceneEngine.search(read);
                sendSearchResultData(toClient, results);
            } catch (IOException e) { e.printStackTrace(); }

            clientSocket.close();
        } catch (IOException e) { e.printStackTrace(); }
    }

    /**
     * 
     * @return a String with the current date and time
     */
    private static String getCurrentTime() {
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");  
        LocalDateTime now = LocalDateTime.now();
        return dtf.format(now);
    }
}
