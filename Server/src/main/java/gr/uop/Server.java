/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package gr.uop;

import java.util.NoSuchElementException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.Scanner;
import java.time.format.DateTimeFormatter; 
import org.apache.lucene.*;


public class Server {
    
    //public final static int QUERY_PORT = 7777, DATA_PORT = QUERY_PORT+1, FILE_PORT=DATA_PORT+1;
    

    public static void main(String[] args) {

        //load port constants
        Path filePath = Paths.get("shared.txt");
        final int QUERY_PORT, DATA_INPUT_PORT, FILE_PORT;
        int qp = 0,dip = 0,fp = 0;
        try (Scanner port_constants = new Scanner(filePath)) {
            qp = Integer.parseInt(port_constants.next());
            dip = Integer.parseInt(port_constants.next());
            fp = Integer.parseInt(port_constants.next());

        } catch (NumberFormatException | IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            System.exit(0);
        }
        QUERY_PORT = qp;
        DATA_INPUT_PORT = dip;
        FILE_PORT = fp;
        //if qp, dip and fp don't change, it means an exception was thrown and the program will stop

        System.out.println("\n\nRunning F.A.L.S.E. back-end.");
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");  
        LocalDateTime now = LocalDateTime.now();  
        System.out.println(dtf.format(now)+"\n\n");
        
        new Thread(()->{
            try (ServerSocket serverSocket = new ServerSocket(DATA_INPUT_PORT)) {
                while(true){
                    Socket clientSocket = serverSocket.accept();
                    handleDataInputConnection(clientSocket);
                }
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }).start();
        
        try (ServerSocket serverSocket = new ServerSocket(QUERY_PORT);) {     
            while(true){
                Socket clientSocket = serverSocket.accept();
                handleQueryConnection(clientSocket, QUERY_PORT);
            }

        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    /**
     * Handles a client data connection
     * @param clientSocket
     */
    private static void handleDataInputConnection(Socket clientSocket) {
        try (ObjectInputStream ois = new ObjectInputStream(clientSocket.getInputStream())) {     
            //won't work with while, for multiple objects make multiple connections
            Object received = ois.readObject();
            System.out.println("Front-end sent object: '"+received.toString()+"' at "+getCurrentTime()+"\n");
            clientSocket.close();
        } catch (IOException | ClassNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    /**
     * Handles a client query connection
     * @param clientSocket the socket to handle
     */
    private static void handleQueryConnection(Socket clientSocket, int port) {          
        try (Scanner input = new Scanner(clientSocket.getInputStream());
             ObjectOutputStream toClient = new ObjectOutputStream(clientSocket.getOutputStream())) {
                
            String read = input.nextLine();
            System.out.println("Front-end sent: '"+read+"' at "+getCurrentTime()+"\n");
            //test objects, must send search results here.
            SongInfo s1 = new SongInfo(read, read, read);
            SongInfo s2 = new SongInfo(read+"1", read+"1", read+"1");
            toClient.writeObject(s1);
            toClient.writeObject(s2);
            toClient.writeObject(null);//MUST send a null object so the client can know there's nothing more to read.
            clientSocket.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    /**
     * 
     * @return a String with the current date and time
     */
    private static String getCurrentTime() {
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");  
        LocalDateTime now = LocalDateTime.now();
        return dtf.format(now);
    }
}
